%form.availability
  .container
    %input#start_date.date.start{:name => "start_date", :value => Date.today, :title => _("Start Date")}
    %label.dateicon{:for => "start_date", :title => _("Open Datepicker")}
  = "-"
  .container
    %input#end_date.date.end{:name => "end_date", :value => Date.tomorrow, :title => _("End Date")}
    %label.dateicon{:for => "end_date", :title => _("Open Datepicker")}
  .checkarea
    %input#available-only.check{:type => "checkbox", :name => "available-only", :value => "available-only", :title => _("Highlight available items.")}
    %label{:for => "available-only", :title => _("Highlight available items.")}
      = _("Available")
 
:javascript

  $(document).ready(function(){
      AvSelector.setup();
  });
  
  var AvSelector = new AvSelector();
  
  function AvSelector() {
    
    this.start_date;
    this.end_date;
    
    this.setup = function() {
      this.seti18n();
      this.setupFromStorage();
      this.setupAvailableOnly();
      this.formatDates();
      this.setupDatepicker();
      this.setupBehaviourOnResize();
      this.checkAvailabilitySelect()
    }
    
    this.checkAvailabilitySelect = function() {
      if($("#available-only").attr("checked") == "checked") {
        AvSelector.hideUnavailable();
      } else {
        AvSelector.showUnavailable();
      }
    }
    
    this.setupAvailableOnly = function() {
      $("#available-only").change(function(){
        if($(this).attr("checked") == "checked") {
          AvSelector.hideUnavailable();
        } else {
          AvSelector.showUnavailable();
        }
        AvSelector.updateStorage();
      });
    }
    
    this.hideUnavailable = function() {
      $("#modellist .item").each(function(){
        if(parseInt($(this).find(".availability .max_available").html()) <= 0) {
          $(this).addClass("unavailable");
          $(this).removeClass("available");
        } else {
          $(this).addClass("available");
          $(this).removeClass("unavailable");
        }
      });
    }
    
    this.showUnavailable = function() {
      $("#modellist .item").each(function(){
        $(this).removeClass("available");
        $(this).removeClass("unavailable");
      });
    }
    
    this.setupBehaviourOnResize = function() {
      $(window).bind("resize scroll", function() {
        
        if (!$("#ui-datepicker-div:visible").length)
          return false;
        
         $("#ui-datepicker-div:visible").position({
           my: "center top",
           at: "center bottom",
           of: $(".openendDatepicker")
         });
      });
    }
    
    this.seti18n = function() {
      $.datepicker.setDefaults(i18n.selected.datepicker);
    }
    
    this.setupFromStorage = function() {
      if(sessionStorage.start_date && JSON.parse(sessionStorage.start_date).length != 0)
        $('#topfilter .availability #start_date').val(JSON.parse(sessionStorage.start_date));
        
      if(sessionStorage.end_date && JSON.parse(sessionStorage.end_date).length != 0)
        $('#topfilter .availability #end_date').val(JSON.parse(sessionStorage.end_date));
        
      if(sessionStorage.available_only && sessionStorage.available_only != "undefined")
        $("#available-only").attr("checked", JSON.parse(sessionStorage.available_only));
    }
    
    this.setupDatepicker = function() {
      var dates = $('#topfilter .availability .date').datepicker({
        minDate: 0,
        showOtherMonths: true,
        selectOtherMonths: true,
        onClose: function(selectedDate, instance) {
          $(this).removeClass("openendDatepicker");
          
          if(this.id == "start_date") {
            var date = $.datepicker.parseDate(i18n.selected.datepicker.dateFormat, selectedDate, instance.settings);
            date = new Date(date.setDate(date.getDate()))
            $('#topfilter .availability #end_date').datepicker( "option", "minDate", date );
          }
          
          AvSelector.updateAvDates();
          AvSelector.updateStorage();
        },
        
        beforeShow: function(input, inst) {
          $(input).addClass("openendDatepicker");
        }
      });
    }
    
    this.updateStorage = function() {
      sessionStorage.start_date = JSON.stringify(formatDate($.datepicker.parseDate(i18n.selected.datepicker.dateFormat, $('#topfilter .availability #start_date').val()), "yyyy-MM-dd"));
      sessionStorage.end_date = JSON.stringify(formatDate($.datepicker.parseDate(i18n.selected.datepicker.dateFormat, $('#topfilter .availability #end_date').val()), "yyyy-MM-dd"));
      sessionStorage.available_only = JSON.stringify($("#available-only").attr("checked"));
    }
    
    this.formatDates = function() {
      $('#topfilter .availability .date').each(function(){
        var date = new Date($(this).val().replace(/-/g, "/")); // SAFARI Workarround for the Date.parse problem
        $(this).val($.datepicker.formatDate(i18n.selected.datepicker.dateFormat, date));
      });
    }
    
    this.updateAvDates = function() {
      var sd = $("#start_date").datepicker("getDate").getTime() / 1000;
      var ed = $("#end_date").datepicker("getDate").getTime() / 1000;
      
      $("#modellist .item").each(function(){
        var availability_all_ips = $(this).tmplItem().data.availability_for_user;
        
        // iterates over all inventory_pools
        var min_quantities_for_each_ip = $.map(availability_all_ips, function(elem){
          // TODO: working here
          // if($.inArray(elem.inventory_pool.id, JSON.parse(sessionStorage.active_ips))) return 0;
          
          var quantities_ip = []; // at the end should contain 0, 1 or 2 elements
          
          // elem.availability is structured as tuple: [[date, quantity], [date, quantity], ...]
          // get all tuples where date is before start_date
          var f1 = elem.availability.filter(function(x){ return (x[0] < sd); });
          // push the most recent quantity to quantities_ip array
          if(f1.length) quantities_ip.push(f1[f1.length-1][1]);
          
          // get all tuples where date is between start_date and end_date
          var f2 = elem.availability.filter(function(x){ return (sd <= x[0] && x[0] <= ed); });
          // push the minimum quantity among the filtered tuples
          if(f2.length) quantities_ip.push(Math.min.apply(Math, $.map(f2, function(x){ return x[1]; })));
          
          // get the minimum quantity from the quantities_ip array, or 0 if it's empty 
          return quantities_ip.length ? Math.min.apply(Math, quantities_ip) : 0;
        });
        
        // sum up the available quantities over all selected inventory pools
        var sum_min_quantities_selected_ips = eval(min_quantities_for_each_ip.join('+'));
        
        // display on the left side the maximal but filtered availability of a model
        $(this).find(".max_available").html(sum_min_quantities_selected_ips);
      });
    }
  }